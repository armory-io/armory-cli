// Code generated by go-makefile project. DO NOT EDIT.
// Source: https://github.com/armory-io/go-makefile/resources/script.sh

// Package main is a generated go-makefile package.
package main

import (
	"bufio"
	"bytes"
	"encoding/json"
	"fmt"
	"github.com/fatih/color"
	"net/http"
	"regexp"
	"sort"
	"strconv"

	"io"
	"k8s.io/utils/strings/slices"
	"log"
	"os"
	"os/exec"
	"strings"
)

var (
	red                   = color.New(color.FgRed)
	boldRed               = red.Add(color.Bold)
	green                 = color.New(color.FgGreen)
	yellow                = color.New(color.FgYellow)
	ghVersionHeader       = []string{"X-GitHub-Api-Version", "2022-11-28"}
	ghAcceptHeader        = []string{"Accept", "application/vnd.github.json"}
	ghAuthorizationHeader = []string{"Authorization", "Bearer "}
	ghContentTypeHeader   = []string{"Content-Type", "application/json"}
)

const (
	REPOSITORY = "GITHUB_REPOSITORY"
	GITHUB_REF = "GITHUB_REF"
	TOKEN      = "GITHUB_TOKEN"
	GH_API     = "https://api.github.com/repos/%s/issues/%s/comments"
	PR_REGEXP = "^.+/pull/(\\d+)/.+$"
	summary = "(statements) (total:)"
)

type TestOutput struct {
	Time    string  `json:"Time"`
	Action  string  `json:"Action"` // output, skip, run, pass, or fail
	Package string  `json:"Package"`
	Output  string  `json:"Output"`
	Elapsed float64 `json:"Elapsed"`
	Test    string  `json:"Test"`
}

type CoverageReport struct {
	Body string `json:"body"`
}

type reportEntry struct {
	entry string
	coverage float64
}

func main() {
	appName := os.Getenv("APP_NAME")
	buildDir := os.Getenv("BUILD_DIR")
	fmt.Println("Fetching packages for test command")
	listCmd := exec.Command("go", "list", "./...")
	var out bytes.Buffer
	listCmd.Stdout = &out
	listCmd.Stderr = os.Stderr
	err := listCmd.Run()
	if err != nil {
		log.Fatal(err)
	}

	args := []string{
		"test",
		fmt.Sprintf("--coverprofile=%s/reports/profile.cov", buildDir),
	}

	packages := slices.Filter(nil, strings.Split(strings.TrimSpace(out.String()), "\n"), func(pkg string) bool {
		return !strings.Contains(pkg, "/e2e")
	})

	args = append(args, packages...)
	args = append(args, "-json")

	cmd := exec.Command("go", args...)

	fmt.Println("Executing the following test command:")
	fmt.Println("------------------------------------------------------------------------------------------------------------------------------------")
	fmt.Println(cmd.String())
	fmt.Println("------------------------------------------------------------------------------------------------------------------------------------")

	cmd.Stderr = os.Stderr

	p, err := cmd.StdoutPipe()
	if err != nil {
		fmt.Printf("Failed to execute command, Err: %s\n", err.Error())
		os.Exit(1)
	}

	done := make(chan bool)
	go streamTestResults(buildDir, p, done)

	err = cmd.Start()
	if err != nil {
		fmt.Printf("Failed to execute command, Err: %s\n", err.Error())
		os.Exit(1)
	}

	<-done
	didTestsPass := true
	if err = cmd.Wait(); err != nil {
		fmt.Printf("\nError while executing tests, Err: %s\n", err.Error())
		didTestsPass = false
	} else {
		fmt.Printf("\nTest run completed without any problems\n")
	}

	fmt.Println("Test command complete, generating html report...")
	reportCmd := exec.Command(
		"go-test-report",
		"--title", appName,
		"-v",
		"--output", fmt.Sprintf("%s/reports/test_report.html", buildDir),
	)
	reportCmd.Stderr = os.Stderr
	testResults, err := os.Open(fmt.Sprintf("%s/reports/tests-results.json", buildDir))
	if err != nil {
		log.Fatal(err)
	}
	reportCmd.Stdin = testResults
	if err = reportCmd.Run(); err != nil {
		fmt.Printf("Error generating html report, err: %s\n", err.Error())
	}
	fmt.Println("html report generation complete")

	if !didTestsPass {
		fmt.Printf("\nATTENTION: The tests failed, exiting 1 now!\n")
		os.Exit(1)
	}
	buildingCodeCoverageReport(buildDir)
}

func streamTestResults(buildDir string, r io.ReadCloser, done chan bool) {
	fmt.Println("Streaming tests results")
	fmt.Println("------------------------------------------------------------------------------------------------------------------------------------")

	var failedTests []string
	path := fmt.Sprintf("%s/reports/tests-results.json", buildDir)
	results, err := os.OpenFile(path, os.O_TRUNC|os.O_CREATE|os.O_WRONLY, 0644)
	if err != nil {
		log.Fatalf("failed creating results file: %s", err)
	}
	writer := bufio.NewWriter(results)
	scanner := bufio.NewScanner(r)
	otherFails := 0
	for scanner.Scan() {
		out := &TestOutput{}
		line := scanner.Text()
		if err := json.Unmarshal([]byte(line), out); err != nil {
			yellow.Printf("%s -> error: %s\n", line, err.Error())
			otherFails++
			continue
		}
		if out.Action == "" {
			continue
		}
		if out.Action == "fail" && out.Test != "" {
			failedTests = append(failedTests, out.Test)
		}
		if strings.HasPrefix(out.Output, "panic:") {
			failedTests = append(failedTests, out.Test)
		}
		trimmedOut := strings.TrimSpace(out.Output)
		if strings.HasPrefix(trimmedOut, "---") || strings.HasPrefix(trimmedOut, "===") {
			colorize(out.Output)
		}
		_, _ = writer.WriteString(fmt.Sprintf("%s\n", line))
	}
	writer.Flush()
	results.Close()
	if len(failedTests) > 0 && otherFails == 0 {
		fmt.Println()
		boldRed.Println("------------------------------------------------------------------------------------------------------------------------------------")
		boldRed.Println("                                                    !!!! TEST FAILURES !!!!")
		boldRed.Println("------------------------------------------------------------------------------------------------------------------------------------")
		for i := len(failedTests) - 1; i >= 0; i-- {
			fmt.Printf("- %s\n", failedTests[i])
		}
		fmt.Println("------------------------------------------------------------------------------------------------------------------------------------")
		fmt.Println("The human readable tests report w/ stdout and stderr will be uploaded in the reports artifact to this workflow")
		fmt.Println("------------------------------------------------------------------------------------------------------------------------------------")
	} else if otherFails > 0 {
		fmt.Println()
		yellow.Println("------------------------------------------------------------------------------------------------------------------------------------")
		yellow.Printf("                                      !!!! Unexpected %d errors when running tests, check syntax?  !!!!\n", otherFails)
		yellow.Println("------------------------------------------------------------------------------------------------------------------------------------")
	} else {
		fmt.Println()
		green.Println("------------------------------------------------------------------------------------------------------------------------------------")
		green.Println("                                                    !!!! ALL TEST PASSED !!!!")
		green.Println("------------------------------------------------------------------------------------------------------------------------------------")

	}
	done <- true
}

func buildingCodeCoverageReport(buildDir string) {
	coverageFile := fmt.Sprintf("%s/reports/function_coverage.txt", buildDir)
	for _, opt := range []struct{ option, target, name string }{
		{
			option: fmt.Sprintf("-html=%s/reports/profile.cov", buildDir),
			target: fmt.Sprintf("%s/reports/coverage_report.html", buildDir),
			name:   "HTML coverage report",
		},
		{
			option: fmt.Sprintf("-func=%s/reports/profile.cov", buildDir),
			target: coverageFile,
			name:   "Function coverage report",
		},
	} {
		args := []string{
			"tool",
			"cover",
			opt.option,
			"-o",
			opt.target,
		}

		fmt.Println("generating report: " + opt.name)
		cmd := exec.Command("go", args...)
		cmd.Stderr = os.Stderr
		cmd.Stdout = os.Stdout
		err := cmd.Run()
		if err != nil {
			red.Println(err.Error())
		}
		fmt.Println()
	}
	fmt.Println("report generation completed - check the generated reports in " + buildDir + "/reports")

	content, _ := os.ReadFile(coverageFile)
	report := string(content)
	green.Println(report)
	fmt.Println()
	tryWriteCoverageAsGithubReport(report)
}

func tryWriteCoverageAsGithubReport(report string) {

	repository := os.Getenv(REPOSITORY)
	ref := os.Getenv(GITHUB_REF)
	token := os.Getenv(TOKEN)

	if repository == "" || ref == "" || token == "" {
		fmt.Println(fmt.Sprintf("update PR skipped due [%d,%d,%d]", len(repository), len(ref), len(token)))
		return
	}

	re := regexp.MustCompile(PR_REGEXP)
	matches := re.FindStringSubmatch(ref)
	if len(matches) != 2 {
		return
	}
	prNumber := matches[1]

	re = regexp.MustCompile("[\t ]+")
	prefix := "github.com/" + repository + "/"
	report = strings.ReplaceAll(report, prefix, "")
	report = strings.ReplaceAll(report, "\r\n", "\n")
	report = re.ReplaceAllString(report, "|")
	lines := strings.Split( report, "\n")
	buffer := strings.Builder{}

	buffer.WriteString("| Function (file) | Coverage |\n")
	buffer.WriteString("|  :---           | :---     |\n")
	entries := []reportEntry{}
	for _, line := range lines {
		if line != "" {
			tokens := strings.Split(line, "|")
			num, _ := strconv.ParseFloat(strings.ReplaceAll(tokens[2], "%", ""), 64)
			entry := reportEntry{
				entry: fmt.Sprintf("%s (%s)", tokens[1], tokens[0]),
				coverage: num,
			}
			entries = append(entries, entry)
		}
	}
	sort.SliceStable(entries, func(i, j int) bool {
		if entries[i].entry == summary {
			return false
		}
		if entries[j].entry == summary {
			return true
		}
		return entries[i].coverage > entries[j].coverage
	})
	for _, entry := range entries {
		buffer.WriteString(fmt.Sprintf("|%s|%.2f %%|\n", entry.entry, entry.coverage))
	}

	body := CoverageReport{Body: buffer.String()}
	bs, _ := json.Marshal(body)
	rdr := bytes.NewReader(bs)

	url := fmt.Sprintf(GH_API, repository, prNumber)
	fmt.Println(url)
	request, err := http.NewRequest(http.MethodPost, url, rdr)
	if err != nil {
		red.Println("could not create request - " + err.Error())
		return
	}
	request.Header.Set(ghVersionHeader[0], ghVersionHeader[1])
	request.Header.Set(ghAcceptHeader[0], ghAcceptHeader[1])
	request.Header.Set(ghAuthorizationHeader[0], ghAuthorizationHeader[1]+token)
	request.Header.Set(ghContentTypeHeader[0], ghContentTypeHeader[1])

	resp, err := http.DefaultClient.Do(request)
	if err != nil {
		red.Println("could not update PR - " + err.Error())
	} else {
		green.Println(fmt.Sprintf("response status code: %d [%s]", resp.StatusCode, resp.Status))
	}
}

func colorize(output string) {
	if strings.Contains(output, "--- PASS") {
		green.Print(output)
		return
	}

	if strings.Contains(output, "--- FAIL") {
		boldRed.Print(output)
		return
	}

	fmt.Print(output)
}
